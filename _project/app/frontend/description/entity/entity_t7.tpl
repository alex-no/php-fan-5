<p>Ближе к концу метода <b>init()</b> файла <b>test_entity.php</b> вы видите четыре примера, демонстрирующих модификацию данных в БД. Все они закомментированы, чтобы не мешать при работе с предыдущими примерами. В рамках самостоятеьной работы Вам необходимо их раскоментировать и проверить их работу. Чтобы было удобнее ставить ибирать комментарий, они написаны таким образом, что вам достаточно просто заменить <b>/*</b> на <b>//*</b>. Т.е добавить или убрать символ "<b>/</b>" в начале каждого комментария.</p>
<p>Первый пример демонстрирует добавление новой записи в таблицу <b>test_subtable</b>. Результат этого действия Вы можете увидеть в примере "Get Bottom rowset by linked table". Только обратите внимание, что результат этого действия Вы видите только после повторной перезагрузки страницы, поскольку во view передаются данные до модификации. По этой причине, во многих случаях, во view рекомендуется передавать не преобразованный массив, а объекты <span class="keyword">row</span> или <span class="keyword">rowset</span>. Эти объекты хорошо адаптированы для работы с ними в шаблоне и других видах view.</p>
<p>Второй пример демонстрирует модификацию поля "header", таблицы "test_primary" для строки с id=1. Обратите внимание что объект <span class="keyword">row</span> для данной операции мы могли-бы получить способом, описанным в первом примере, но это было-бы целесообразно, если-бы нам надо было где-то еще использовать значения других полей из этой записи. Если мы хотим выполнить только <b>UPDATE</b> без предварительного <b>SELECT</b>, то целесообразно использовать метод <b>initIdOnly()</b>. Результат этого действия Вы увидите в примере "Get Top row from linked table", но как и предыдущем случае, после повторной перезагрузки страницы.</p>
<p>Третий пример демонстрирует изменение комментария к таблице "test_subtable". Результат этого действия Вы увидите в примере "Table description for test_subtable", после перезагрузки страницы.</p>
<p>Четвертый пример демонстрирует возможность обратиться к произвольной таблице в БД, без предварительного создания соответствующего класса для нее. Точнее класс, унаследованный от <b>\core\base\model\entity</b> необходим, но он располагается в произвольном месте, без соблюдения выше описанных правил. Т.о. объект этого класса может работать с любой таблицей в БД. Название таблицы и другие параметры, указываются при получении этого объекта из сервиса "entity". Дальнейшая работа с этим объектом ведется как и с <span class="keyword">entity</span>, полученным стандартным способом. Здесь мы получаем <span class="keyword">row</span> с id=18 и меняем значение его поля "<b>header</b>". Сейчас значение этого поля: <b>{=isset($test_arbitrary) ? $test_arbitrary->header : 'unknown'}</b>. Данный способ получения <span class="keyword">entity</span> может быть использован например, в тех случаях, когда новые таблицы в БД появляются в процессе работы скрипта и зараннее их названия определить невозможно.</p>
