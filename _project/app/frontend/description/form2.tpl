<p>Допускается основной блок страницы использовать как составляющие элементы формы. Но более правильным решением будет выделение каждой формы в отдельный блок и размещение этих блоков в отдельной директории. Именно так и сделано в данном тесте - элементы данной формы расположены в каталоге <b>{$form_block['dirname']}</b>:</p>
<dl class="form_elements">
    <dt>{$form_block['filename']}.meta.php</dt><dd>- meta-файл со структурой формы.</dd>
    <dt>{$form_block['basename']}</dt><dd>- основной контроллер формы.</dd>
    <dt>{$form_block['filename']}.tpl</dt><dd>- шаблон формы.</dd>
</dl>
<p>Данная форма сравнительно простая - всего три поля (изучите meta-файл этого блока). Все три поля представлены как типовые (наиболее распространенный способ представления: лейбл, поле для ввода/выбора информации, примечание, сообщение об ошибке). Рассмотрите внимательно шаблон формы - здесь два поля "text1" и "variant" представлены в сокращенном виде: <b>{ldelim}form_row name='text1'{rdelim}</b> и <b>{ldelim}form_row name='variant'{rdelim}</b>. А для поля "date" составляющие элементы этого поля разделены: <b>&lt;div class="formRow"&gt;{ldelim}form_label name='date'{rdelim}{ldelim}form_field name='date'{rdelim}{ldelim}form_error name='date'{rdelim}{ldelim}form_note name='date'{rdelim}&lt;/div&gt;</b>. Такое разделение дает верстальщику определенную свободу в манипуляции элементами не стандартной формы, но усложняет читабельность шаблона. Во многих случаях, для решения такой задачи, гораздо целесообразнее изменить или добавить "паттерн шаблона" в мета-данные блока. Что такое "паттерн шаблона" вы можете понять, заглянув в метафайл, расположенный рядом с классом: \fan\core\block\form\usual, от которого наследуются все блоки форм.</p>
<p>Теперь рассмотрим php-файл формы. Он достаточно простой (4 метода по 1-2 процедуры в каждом). Большинство классов форм в PHP-FAN достаточно простые за счет того, вся структура формы задана в мета-данных, а обработка формы, согласно структуре происходит в родительских классах и в сервисе <span class="keyword">form</span>. В методе init() следует обратить внимание вызов метода <b>$this-&gt;_parseForm();</b> - именно в этот момент происходит вызов сервиса <span class="keyword">form</span> и обработка данных, переданных с помощью формы. Порядок обработки описан ниже. Успешно обработанные данные сохранются в сессии (см. метод onsubmit()), а после перезагрузки страницы извлекаются (см. метод init()) и передаются во view для отображения. Метод <b>checkDate</b> демонстрирует как для форм можно создавать свои, не стандартные, правила валидации (обратите внимание на то, как этот метод обозначен в meta-файле). Метод <b>getVariants</b> демонстрирует как таких элементов как select, radio, и.т.д. можно динамически генерировать список данных. Сейчас этот метод возвращает обычный статичный массив, но на практике такие данные формируются динамически из БД или других источников.</p>
<p>Рамки данного теста не позволяют раскрыть всех возможностей, которые есть в PHP-FAN для работы с формами. Тем не менее раскрытых здесь возможностей хватает для построения большинства форм. Для решения более сложных вариантов следует обратиться к документации.</p>



<h2>Принципы работы с HTML-формами в PHP-FAN</h2>

<p>Каждая форма в PHP-FAN выполняется в виде одного блока или нескольких блоков. Другими словами, одна форма может состоять из нескольких блоков, но никогда один блок не должен включать в себя несколько форм. Т.о. формы в PHP-FAN можно разделить на два вида:</p>
<dl class="art_def2">
    <dt>Одно-блочные</dt>
    <dd>- весь функционал формы выполняется в виде одного блока, который выполняет все действия от прорисовки HTML-кода формы, до обработки результатов.</dd>
    <dt>Много-блочные</dt>
    <dd>- вся форма разбивается на несколько частей (блоков). Каждая часть может включать в себя один или несколько элементов (тегов) формы.</dd>
</dl>
<p>В многоблочных формах один из блоков, составляющих форму, обозначается как <b>основной</b>. Чаще всего это блок включающий в себя остальные блоки, но не обязательно - как основной может быть отмечен и вложенный блок (как удобно из логики обработки данных). Все остальные блоки называются "<b>части формы</b>" или <b>form_part</b>. Для обозначения частей входящих в форму используется специальный параметр в meta-файле - "form_parts". <u>Каждый блок контролирует свою часть формы</u> (формирует HTML-код, валидирует и обрабатывает полученные данные). При обработке данных, сначала валидируются и обрабатываются данные частей (порядок обработки задается в массиве form_parts). Если произошла ошибка внутри части, в основной форме тоже выставляется флаг ошибки, но сообщения об ошибках остаются и выводятся внутри каждой части. Обработанные данные передается в основной блок и сохраняются в отдельном массиве. Окончательные, консолидированные данные получаются из основной формы так же как из одно-блочной формы, с помощью метода getFieldValue().</p>
<p>Многоблочные формы имеют смысл в тех случаях, когда один и тот же достаточно сложный фрагмент формы, используется в нескольких частях проекта, чтобы избежать копирования структуры и обработчика формы. Также разделять на фрагменты можно сильно сложные формы для удобочитаемости.</p>

<p>Работу с любой формой можно разделить на несколько шагов:</p>
<ol class="article_list">
    <li><b>Получение структуры формы</b> - источником данных здесь служит мета-файл файл блока с формой или субформой.{* В мультиформах - основной блок собирает данные от субформ и формирует общую структуру.*}</li>
    <li><b>Передача данных для валидации в JavaScript</b> - выполняет блок формы (в мультиформах - основной блок).</li>
    <li><b>Подготовка данных для элементов</b> - некоторые элементы (select, radio, checkbox и т.п.) требуют дополнительные данные для отображения. Способ получения таких данных определяется в мета-файле. Данные берутся либо из самого мета-файла, либо их возвращает метод текущего блока, либо статический метод произвольного класса (обычно это класс entity).</li>
    <li><b>Подготовка исходных значений элементов</b> - в некоторых случаях требуется сделать предзаполнение элементов формы (например, вписать определенный текст в input-text, выбрать определенную опцию у select и т.п.). Эта информация либо также указывается в meta-файле, либо задается вызовом специального метода.</li>
    <li><b>Формирование HTML-кода</b> - каждый блок формирует свою часть формы. Элементы формы формируются с помощью паттернов, которые описаны ниже. Полный HTML-код многоблочной формы формирует блок, в который включены остальные блоки (шаблон этого блока должен содержать теги &lt;form&gt; и &lt;/form&gt;). Сформированный код передается или в общий HTML-шаблон или отдается в JavaScript для динамического отображения.</li>
    <li><b>Предварительная валидация в JavaScript</b> - выполняется в браузере клиента, в процессе заполнения формы клиентом или непосредственно перед отправкой на сервер. Такая валидация не позволяет пользователю отправлять не валидные данные на сервер, чем ускоряется работа пользователя с формой и снижается нагрузка на сервер.</li>
    <li><b>Отправка данных на сервер</b> - выполняется либо стандартным способом, либо с помощью JavaScript. В зависимости способа отправки, обработка формы выполняется по разному.</li>
    <li><b>Валидация и подготовка данных</b> - выполняется с помощью класса <b>\core\service\form</b>. Объекты этого класса создаются отдельно для каждого блока субформы и, соответственно обрабатывает свою часть данных. Стоит отметить, что валидация, описанная в 6-м шаге может легко обходиться хакерами и поэтому все данные формы, не зависимо от валидации в JavaScript, должны повторно валидироваться на сервере.</li>
    <li><b>Обработка данных</b> - если валидация данных прошла успешно то вызывается метод <b>onSubmit</b> основного блока и в него передаются подготовленные данные.</li>
    <li><b>Перезагрузка</b> - если данные формы были переданы методом POST и обработка данных прошла успешно, то обычно после этого происходит перезагрузка страницы. Такая перезагрузка защищает пользователя от случайной повторной отправки данных на сервер. Обычно перезагрузка происходит по текущему URL и после перезагрузки пользователю в корневом блоке отображается не форма, а информация об успешной обработке переданных данных.</li>
    <li><b>Информация об ошибках</b> - к этому шагу переходим если на 8-м шаге при валидации были обнаружены ошибки. После этого возвращаемся ко 2-му шагу, но с небольшой оговоркой - на 4-м шаге, в качестве исходных значений используем данные введенные пользователем, а на 5-м шаге вместе с элементами формы выводятся сообщения об ошибках.</li>
</ol>
<p>Отдельно необходимо рассмотреть шаг 6 "Предварительная валидация в JavaScript". Часть данных для валидации формы передается в JavaScript вместе со сформированным HTML-кодом формы. Сюда относятся правила валидации на основе статичных данных: обязательность заполнения, соответствие регулярному выражению, число в заданном диапазоне и т.п. Но некоторые способы валидации (например, проверка уникальности введенного логина или email) требуется дополнительный запрос к серверу. При этом URL для такого запроса должен быть составлен таким образом, чтобы выполнялась только валидация указанного поля/полей с помощью сервиса <b>\core\service\form</b>, но по правилам, описанным в блоке с формой. Другими словами, не должно быть дублирующего описания правил валидации в разных блоках.</p>

<p>С точки зрения практического использования формы можно разделить на две группы:</p>
<dl class="art_def2">
    <dt>Формы-фильтры</dt>
    <dd>- эти формы используются для ограничения списка выводимых данных (данные выводятся в другом блоке). Такие формы не имеют метода <b>onSubmit</b> (см. 9-й шаг), точнее этот метод пустой, т.к. данные передаваемые на сервер никак не обрабатываются формой (точнее никуда не заносятся, кроме, может быть статистики, но это отдельный процесс). К формам такого типа относятся и поисковые формы. Формы такого типа обычно передают свои данные методом GET (чтобы полученную ссылку можно было внести в закладки, переслать другим пользователям и т.д)</dd>
    <dt>Формы-инъекторы</dt>
    <dd>- эти формы используются для передачи каких-либо данных на сервер. Это могут быть, как формы, данные которых сохраняются на сервере (например, регистрация новых пользователей), так и формы, данные которых просто проверяются (проверка логина/пароля). В любом случае данные такой формы после валидации требуют дополнительной обработки в методе <b>onSubmit</b>.</dd>
</dl>
<p>Имеет смысл, на уровне проекта, создать два промежуточных класса для этих двух групп, прописать в них основные свойства и методы, а все типовые формы в проекте наследовать от одного из этих классов.</p>

<p>С точки зрения дизайна формы можно разделить тоже на две группы:</p>
<ul class="article_list">
    <li><b>Типовые формы</b> - каждый элемент формы представлен в виде нескольких стандартных элементов: лейбл -&gt; тег элемента формы -&gt; примечание к элементу -&gt; сообщение об ошибке.</li>
    <li><b>Не стандартные</b> - каждый элемент формы выводится в произвольном виде.</li>
</ul>

<h2>Комбинированные элементы HTML-форм</h2>

<p>Очень часто данные форм представляются не как скалярные величины, а как массивы (часто многомерные). В PHP-FAN есть две методики для работы с такими данными:</p>
<ul class="article_list">
    <li><b>С указанием "глубины" поля</b> - здесь для полей в мета-данных указывается параметр "depth". Для обычных полей значение этого параметра равно 0. Если данные представляются в виде одномерного массива - этот параметр равен 1; для двумерного массива - 2; и т.д. Если глубина массива не указана, а значение полученное от клиента содержит массив или если указанная глубина не соответствует полученным данным, но такие данные игнорируются и появляется сообщение об ошибке. Этот способ передачи данных удобен при передаче множества однотипных данных, т.к. такое поле в мета-файле описывается только один раз, не зависимо от количества передаваемых в этом поле данных.</li>
    <li><b>С использованием комбинированных названий в структуре формы</b> - для полей этого типа, названия полей в мета-файле указывается "как есть". Т.е. так как они потом будут выглядеть в атрибуте "name", а именно - с квадратными скобками, например: <b>song[lst2]</b>. В названиях таких полей используются только: цифробуквенные символы, символ подчеркивания "_" и квадратные скобки "[ ]". Практическое назначение этого способа передачи данных менее очевидно и может быть продиктовано спецификой проекта.</li>
</ul>
<p>Не зависимо от способа представления массивов данных, обращение к полученным данным происходит с помощью комбинированного ключа (в виде массива, вместо обычной скалярного ключа). Например, если имеем данные $_POST[song][lst2], то для получения их необходимо примерно такую процедуру: $this->getForm()->getFieldValue(array('song', 'lst2')). Аналогично, в шаблоне для паттерна конкретного элемента формы в качестве "name" указывается не строка, а массив (важно для предзаполнения формы).</p>
<p><i>Маленький offtop</i>: обратите внимание, что подобный метод получения данных из массивов или из ArrayAccess-объектов используется в разных частях PHP-FAN. Например, при получении мета-данных, данных из конфигов и т.п. Более того, с помощью функции array_val() таким способом можно получить данные из любого массива.</p>
