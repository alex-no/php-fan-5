<p>Try to go to next URI / Попробуйте перейти по следующим ссылкам:</p>
<ol>
    <li><a href="/test/format/format-html">/test/format/format-html</a></li>
    <li><a href="/test/format/format-json">/test/format/format-json</a></li>
    <li><a href="/test/format/format-xml">/test/format/format-xml</a></li>
    <li><a href="/test/format/format-loader">/test/format/format-loader</a></li>
    <li><a href="/test/format/format-custom1">/test/format/format-custom1</a></li>
    <li><a href="/test/format/format-custom2">/test/format/format-custom2</a></li>
</ol>


<p>
    Данный файл демонстрирует основные действия, необходимые для вложения блоков. Глубина вложенности блоков может быть неограниченной и допускается для всех форматов view. Для того чтобы вложить блок в другой блок необходимо в мета-файле указать параметр "<span class="keyword">embeddedBlocks</span>" (см. мета-файл <span class="keyword">test_format.meta.php</span>). Следует заметить, что каждому вложенному блоку в meta-файле присваивается уникальное имя, которое может отличаться от названия класса вложенного блока (<i>здесь класс "test_format", а имя "extra"</i>). Класс вложенного блока нужно указывать либо с полным namespace, либо с использованием placeholders (<i>здесь "placeholder {CAPP}" обозначает "Current application"</i>). Болеее детально о вложении блоков мы рассмотрим в отдельном тесте{*ToDo: link to this test*}.
</p>
<p>
    Имена вложенных блоков используются по-разному во view разных форматов. Например, для <span class="keyword">HTML-формата</span> в шаблоне указывается "переменная шаблона" с именем блока, обозначающая место, куда должно помещаться содержимое вложенного блока. А для <span class="keyword">XML-</span> или <span class="keyword">JSON-формата</span> имя блока используется как название xml-тега или ключа, соответственно. Попробуете кликать по ссылкам приведенным выше и посмотрите как изменится внешний вид данной страницы. Для возврата к текущей странице испоьзуйте кнопку "Back" вашего браузера.
</p>
<p>
    Обращаю внимание, что для формирования данных для view, во всех вышеприведенных ссылках происходит с помощью одного и того-же контроллера. Т.е. всегда во view передаются одни и те-же данные, но выводятся они по разному. В html отображаются только те данные, которые указаны в шаблонах и в соответствии со структурой шаблонов. В JSON, XML и т.п. структура документа определяется структурой данных, переданных во view. При этом данные вложенных блоков образуют отдельную "ветку" с ключом, соответствующим названию вложенного блока. Все это Вы можете увидеть просмотрев внимательно исходные php-коды и сравнив их с результатом полученным в браузере.
</p>

{if !$adv}
<p>
    <hr />
    Если Вы только осваиваете PHP-FAN, Вам лучше вернуться к этому тесту позже. Но если Вы хотите прямо сейчас освоить более сложные операции с view - кликните <a href="?advanced=1#adv-info">здесь</a>.
</p>
{else}

<a name="adv-info" ></a>
<p>
    Существует несколько способов указать, какой именно <span class="keyword">формат view</span> использовать для того или иного запроса:
</p>
<ul>
    <li>С помощью правил в config-файле (см. описание правил ниже), по которым анализируется запрос клиента. По первому правилу, которое подходит под текущий запрос - определяется <span class="keyword">формат view</span></li>
    <li>Если ни одно из правил не сработало - используется значение по умолчанию, которое получается первым из доступных способов:
        <ul>
            <li>значение default_view_format, указанное в meta-файле основного блока (Попробуйте раскомментировать значение указанное в meta-файле данного блока и перезагрузить страницу);</li>
            <li>значение default_format для view, указанное в config-файле;</li>
            <li>используется <span class="keyword">HTML-формат</span>.</li>
        </ul>
    </li>
    <li>Если для какого-либо запроса нужно задать особое правило опрделения формата - в основном блоке задайте метод "getViewParserName". Этот метод должен возвращать суффикс для для класса view-parser (название класса без учета namespace). Значение воззвращаемое данным методом будет иметь самый высокий приоритет, перед осталными способами определения форамта, поэтому побеспокойтесь о том, что если условие необходимое вам для определения view не выполняется, то должны использоваться стандартные процедуры определения.</li>
    <li>Если Вы хотите изменить принципы определения view в целом для всего проекта, - Вы можете создать свой класс \project\view\definer, унаследовав его от \core\view\definer и переопределить в нем соответствующие методы.</li>
</ul>

<p>
    Разберем, как описываются правила определения <span class="keyword">формата view</span> в конфигурационном файле. Для этого изучим секцию <b>[tab.VIEW_DEFINER]</b> файла service.ini. Все правила, описанные в этом файле будут отрабатывать в том порядке в котором они описаны, поэтому порядок определения очень важен. Для каждого формата можно указать несколько правил, например: <b>rule.json.0</b>, <b>rule.json.1</b>, <b>rule.json.2</b>, и т.д. При этом вы можете, например, написать правило для json, затем для xml, затем опять для json (это может оказаться важным для установки приоритетов), но при этом не должен повторяться числовой индекс, в конце ключа для правил одного формата view. Ключевым элементом правила является строка, состоящая из четырех элементов, разделенных точкой:
</p>
<ol>
    <li>Источник данных для <a href="/test_service_request.html">сервиса request</a> - состоит из символов "ABCEFGHMOPRS".</li>
    <li>Ключ массива, для указанного источника данных в <a href="/test_service_request.html">сервисе request.</a></li>
    <li>Способ анализа параметра, полученного из указанного источника:
        <ul>
            <li><b>s</b> <i>string</i>  - параметр, как строка, сравнивается со значением указанным в четвертом элементе;</li>
            <li><b>i</b> <i>integer</i> - параметр, как целое число, сравнивается со значением указанным в четвертом элементе;</li>
            <li><b>n</b> <i>numeric</i> - параметр, как число, сравнивается с выражением указанным в четвертом элементе (выражение должно подходить под регулярное выражение <b>/^(\=\=|\!\=|\>\=?|\<\=?)?(\-?[0-9]+(\.[0-9]+)?)$/</b>;</li>
            <li><b>b</b> <i>boolean</i> - параметр, анализируется как булево значение. При этом, если в четрертом параметре указано true, то значение используется "как есть", в противном случае - инвертируется;</li>
            <li><b>r</b> <i>regexp</i>  - параметр, как строка, передается в релярное выражение указанное в четвертом элементе.</li>
        </ul>
    </li>
    <li>Для способов "<b>b</b>" и "<b>i</b>" значение переданное в этом элементе используется "как есть", а для остальных способов - это индекс из вспомогательного массива <b>tab.VIEW_DEFINER.value</b>.</li>
</ol>
<p>
    Анализ, согласно правилам, происходит следующим образом: берется значние из запроса, согласно первым двум элементам строки правила. Затем определяется способ анализа, и с помощью значения полученного из четвертого параметра, собственно происходит выполнение правила. В одном правиле может использоваться несколько выражений, разделенных операторами "&&" или "||", а также с испрользованием скобок. Таким образом, можно создавать довольно сложные правила, с исключениями.
</p>

<p>
    Разберем примеры представленные в конфиг-файле:<br />
    <b>PG.dl_ctrl.b.1</b> - такая запись означает, что из массива $_POST или $_GET (<b>PG.</b>) будет взят элемент с ключом (<b>.dl_ctrl.</b>) полученное значение будет преобразовано в булев тип (<b>.b.</b>) и если полученное значение будет true (<b>.1</b>), то условие выполнено;<br />
    <b>H.X-Requested-With.s.0</b> - такая запись означает, что из заголовков (<b>H.</b>) будет взят элемент с ключом "X-Requested-With" (<b>.X-Requested-With.</b>) и полученное значение будет преобразовано в строку (<b>.s.</b>). Затем эта строка будет сравниваться с нулевым элементом из массива <b>tab.VIEW_DEFINER.value</b> - (<b>.0</b>). Если строки совпадут, то условие выполнено;<br />
    <b>APG.format.s.3</b> - такая запись означает, что из массива $aAddRequest, $_POST или $_GET (<b>PG.</b>) будет взят элемент с ключом "format" (<b>.format.</b>) и полученное значение будет преобразовано в строку (<b>.s.</b>). Затем эта строка будет сравниваться с третьим элементом из массива <b>tab.VIEW_DEFINER.value</b> - (<b>.3</b>). Если строки совпадут, то условие выполнено;
</p>

<p>
    Для работы с view используются четыре основные класса:
</p>
<ul>
    <li><b>\core\view\definer</b> - определяет какой тип view использовать для показа результатов данного запроса (этот класс описан выше);</li>
    <li><b>\core\view\keeper</b> - значения передаваемые во view могут разделятся на несколько видов и для хранения каждого вида используется свой keeper (<i>класс может быть переопределен для некоторых <span class="keyword">форматов view</span></i>);</li>
    <li><b>\core\view\router</b> - определяет какой тип view использовать для показа результатов данного запроса (<i>класс может быть переопределен для некоторых <span class="keyword">форматов view</span></i>). По умолчанию, для всех видов данных, для которых не указан специальный router - используется \core\view\router\simple;</li>
    <li><b>\core\view\paser</b> - основной класс для обработки данных переданных во view (<i>абстрактный класс испльзуется для наследования</i>). Для каждого <span class="keyword">формата view</span> используется свой класс parser;</li>
</ul>
<p>
    В рамках данного теста создано два дополнительных нестандартных парсера: \project\view\parser\custom1 и \project\view\parser\custom2. Как написано выше, для использования этих парсеров у основного блока задан метод "getViewParserName". Оба этих класса должны иметь методы: <b>статический getType</b>, возвращающий название данного парсера и <b>getFinalContent</b>, возвращающий конечный текст на основе данных из view-keeper данного блока. Рассмотрите исходный код названых классов, для анализа принципов их работы.
</p>
{/if}
