<p>
    Данный файл демонстрирует работу с сессиями. В системе предусмотрено много уровней изоляции данных сохраняемых в сессии. Здесь мы рассмотрим основные.
</p>
<h2>Изоляция на уровне текущего application</h2>
<p>
    Этот тип изоляции используется по умолчанию, т.е. <span class="keyword">сервис session</span> вызывается без каких-либо параметров. При этом данные, сохраняемые в сессию, будут доступны только в пределах данного application. Другими словами, если например в application "frontend" сохранить в сессию элемент с ключом "x1", то в другом application этот элемент не будет доступен. Более того, в другом application можно сохранить другой элемент с ключом "x1" и они не пересекутся. При этом, на уровне php сохранение сессии выполняется как обычно, в массив $_SESSION, но обращаться к этому массиву напрямую категорически не рекомендуется.
</p>
<h2>Изоляция на уровне блока</h2>
<p>
    Данные, которые сохраняются в сессию таким способом, будут доступны только объектам (блокам) текущего класса. Другими словами, если Вы сохраняете какое-либо значение таким способом, то из блоков созданных на основе других классов эти данные не будут доступны. Для удобства сохранения/получения данных использутся методы: <span class="keyword">$this->setSessionData($sKey, $mValue);</span> / <span class="keyword">$this->getSessionData($sKey);</span>. Очень часто сессия используется для однократной передачи данных между друмя сеансами. Т.е. при одном обращении даные сохраняются в сессию, а при последующем обращении должны быть прочитаны и удалены из сессии. Для упрощения этого процесса и предназначен третий параметр метода <b>getSessionData</b>.
</p>
<h2>Custom-данные</h2>
<p>
    Существуют отдельные массивы данных типа "custom". Для таких данных указывается "<b>namespace</b>" в виде любой текстовой строки (не путать с namespace класса), при вызове объекта <span class="keyword">сервиса session</span>. Указывается "<b>namespace</b>" как второй аргумент функции service, например: <b>service('session', 'ns1')</b>. Область видимости таких данных ограничена только указанным "<b>namespace</b>" и при правильном его указании, эти данные будут доступны из любой точки проекта, не зависимо от application и других условий.
</p>
<h2>Общая информация</h2>
<p>
    В сессии можно сохранять не только скалярные величины но и массивы или объекты. Если все свойства сохраняемого в сессии объекта, являются скалярными величинами, то обычно такие объекты сохраняются без каких-либо дополнительных методов. Для сложных классов лучше использовать "implements Serializable". Если есть возможность восстановить какие-то свойства объекта после чтения его из сессии, то во многих случаях нецелесообразно сохранять эти свойства в сессии. Характерным примером являются объекты класса <b>\core\base\model\row</b>, специально адаптированные для сохранения в сессии или <a href="test_cache.php">кэше</a>. Такой объект (запись из БД), содержит ссылку на объект entity, с помощью которого он был получен. При этом ссылка на объект entity в сессию не сохраняюется, но сохраняются параметры, с помощью которых этот объект может быть восстановлен.
</p>
<p>
    В сессии сохраняются еще множество служебных данных, например: данные авторизованного пользователя и его роли, некоторые сервисы хранят свою информацию в сессии, и т.д. Для таких данные создаются отдельные группы namespace и, при использовании вышеописанных методов работы, эти данные никогда не "пересекутся". Прямое обращение к служебным данным (даже через <span class="keyword">сервис session</span>) категорически не рекомендуется. Для работы с такими данными используйте те сервисы, для которых они предназначены.
</p>