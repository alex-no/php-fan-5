<article>
    <h1 class="header">PHP-FAN.5: Test of operation with DB by entity<span> / PHP-FAN.5: Проверка работы с БД при помощи entity</span></h1>
{if $isCorrect}
    <p>Материал, описанный ниже, поначалу покажется Вам очень сложным и запутанным. Но это только на первый взгляд. Если у Вас нет опыта работы с PHP-FAN (хотя-бы предыдущих версий), то лучше не пытаться пройти все примеры за один раз. Лучше детально разберите работу с первыми двумя примерами, а через некоторое время с третьим, четвертым и т.д. После того как Вы дойдете до последнего примера Вы поймете, что работа с <span class="keyword">entity</span> проста до "безобразия". Удачи! ;)</p>
    <h2>Краткая информаци об объектах entity/rowset/row</h2>
    <p>PHP-FAN предоставляет досточно простой и удобный способ доступа к данным - классы: <span class="keyword">entity/rowset/row</span>. Объект класса <span class="keyword">entity</span> - это некая сущность, представляющая собой образ источника данных. Данные получаются в виде "строк". Каждая строка представляется объектом класса <span class="keyword">row</span>. Несколько строк данных можно получить в виде объекта класса <span class="keyword">rowset</span>. Классы <span class="keyword">rowset/row</span> имеют методы <b>toArray()</b>, позволяющие легко преобразовывать полученные данные в массивы. Класс <span class="keyword">rowset</span>, кроме этого, имеет еще несколько методов (<b>getArrayAssoc, getColumn, getArrayHash)</b> позволяющих преобразовывать полученные данные в различные массивы.</p>
    <p>В настоящее время класс <span class="keyword">entity</span> может работать только с одним источником данных - БД MySQL. Однако сейчас идет работа над тем, чтобы была возможность получать данные из самых разных источников, среди которых могут быть не только различные БД, но и SOAP, REST, файловая система и др. Пока рассмотрим работу только с БД MySQL.</p>
    <p>Для каждой таблицы БД создается отдельный класс <span class="keyword">entity</span> (<b>rowset/row</b> создавать не обязательно, но можно, если это необходимо). Изначально класс <span class="keyword">entity</span> может быть "пустышкой" (<i>обладать только свойствами/методами родительских классов</i>), при условии, что название каталога, в котором он находится в точности совпадает с названием таблицы в БД (<i>иначе в этом классе дополнительно прописываются свойства/методы определяющие источник</i>). Но Вы можете потом добавлять в этот класс свои методы для дополнительной обработки данных или переопределять родительские методы, если это необходимо. Методы класса <span class="keyword">entity</span> позволяют получать, как <span class="keyword">row</span> так и <span class="keyword">rowset</span> примерно одинаковыми способами:</p>
    <ul class="article_list">
        <li><b>getRowById</b> - получить row по id (для rowset нет аналога). id может передаваться как скалярное значение или как массив, если ключевых полей несколько.</li>
        <li><b>getRowByParam/getRowsetByParam</b> - получить row/rowset по значениям одного или нескольких полей. Если при получении row, параметры указаны таким образом, что MySQL вернет несколько строк, то выбирается первая строка, либо Вы указываете "сдвиг" и получаете нужную строку из результата. Кроме того, при вызове этого метода Вы можете указать порядок сортировки. Для rowset можно указать limit - максимальное количество строк, которое мы хотим получить в результате.</li>
        <li><b>getRowByKey/getRowsetByKey</b> - методы во многом идентичны предыдущим, с той лишь разницей, что в предыдущем случае запрос к БД генерируется автоматически, а здесь мы пишем его сами. Условно говоря, название файла с SQL-запросом и будет тем самым "ключом", который нам необходимо передавать в эти методы. Остальные параметры (лимит, сдвиг, сортировка) используются как и в предыдущем случае. Тексты SQL-запросов условно разделяются на две группы: с классическими плэсхолдерами (в виде символа <b>?</b>) и с "<b>условными комметариями</b>" (более подробно эта тема будет раскрыта в отдельной статье). Следует отметить, благодаря "ручному" написанию SQL-запроса здесь в <span class="keyword">row</span> попадают не только поля таблицы, указанной в <span class="keyword">entity</span>, но и данные из других связанных таблиц. Во избежание ошибок, для "чужих" данных рекомендуется присваивать алиасы, начинающиеся с двух символов подчеркивания "__".</li>
        <li><b>getRowByQuery/getRowsetByQuery</b> - методы аналогичны предыдущим, с той лиш разницей, что вместо "ключа запроса" здесь передается сам "текст SQL-запроса". Сортировка здесь отдельно не указывается, т.к. она может быть указана в самом SQL-запросе. Эти методы следует использовать только в крайних случаях, когда по каким-либо причинам, использование <b>getRowByKey/getRowsetByKey</b> - невозможно.</li>
    </ul>
    <p>Для упрощения доступа к классам <span class="keyword">entity/row</span> существуют специальные функции:</p>
    <ul class="article_list">
        <li><b>ge</b> (сокращение от "get entity") - возвращает объект класса <span class="keyword">entity</span>. Первым аргументом здесь передается <b>namespace</b>, неодходимого класса. Можно передавать полное значение <b>namespace</b>, но для удобочитаемости префикс "project/model" лучше опускать. Например, вместо "<b>project\model\common\test_primary</b>" лучше писать "<b>common\test_primary</b>". Функция имеет еще два дополнительных параметра, которые будут описаны отдельно.</li>
        <li><b>gr</b> (сокращение от "get row") - возвращает объект класса <span class="keyword">row</span>. Первый аргумент этой функции, как и в предыдущем случае "сокращенный namespace". Второй, необязательный параметр, это id записи в БД. Если id не указан - создается "пустая row", данные которой используются для вставки новой записи в БД (<i>INSERT</i>). Остальные параметры функции будут описаны отдельно.</li>
    </ul>
    <p>Объект класса <span class="keyword">rowset</span> является итератором, т.е. его можно использовать в циклах. Значения полей из объекта <span class="keyword">row</span> могут извлекаться несколькими способами: <b>$oRow->field_name, $oRow['field_name'], $oRow->get('field_name')</b>. Первый способ самый простой, но его можно использовать только если имя поля в БД содержит допустимые символы. Во втором и третьем способе поля могут называться как угодно. Третий способ позволяет еще указывать значение по умолчанию и запретить exception, если идет обращение к не существующему полю. Получить значения всех полей, как уже писалось выше можно с помощью метода toArray. Для задания новых значений в <span class="keyword">row</span>, соответсвенно существуют следующие способы: <b>$oRow->field_name = ..., $oRow['field_name'] = ..., $oRow->set('field_name', ...)</b>. Данные заданные в <span class="keyword">row</span> не сразу попадают в БД. Для того чтобы это произошло, необходимо у этого объекта вызвать метод <b>save</b> (<i>Для row, полученной без загрузки произойдет INSERT, а для "загруженной row" - произойдет UPDATE</i>).</p>

{*==== Test SELECT row by ID / Проверка загрузки row по ID ====*}
    <h2>Test SELECT row by ID / Проверка загрузки row по ID</h2>
    <dl class="result">
        <dt>Строка, полученная из таблицы "test_primary": </dt> <dd><pre>{$row_by_id}</pre></dd>
    </dl>

    <p>В этом примере мы получаем запись из БД по ID и выводим результат как массив, содержащий значения полей записи. Это самый простой и, пожалуй, самый часто употребляемый, способ получения записей из БД.</p>

{*==== Test SELECT row by Key / Проверка загрузки row с помощью ключа ====*}
    <h2>Test SELECT row by Key / Проверка загрузки row с помощью ключа</h2>
    <dl class="result">
        <dt>Строка, полученная из таблицы "test_primary": </dt> <dd><pre>{$row_by_key}</pre></dd>
    </dl>

    <p>В этом примере мы получаем запись из БД при помощи ключа "less_than". В указанном SQL-запросе мы выбираем все записи id которых меньше <b>18</b> (значение передается в параметрах). Далее мы сортируем полученные начения по id в обратном порядке (сортировка тоже указана в параметрах) и выбираем строку со смещением на <b>1</b>. Одной фразой это вожно сказать так: "<b>Выбрать предпоследнюю строку, id которой меньше 18</b>". Обратите внимание, что в данном примере, в отличие от предыдущего, мы сначала получаем объект <span class="keyword">entity</span>, а потом уже с помощью метода <b>getRowByKey</b> получаем объект <span class="keyword">row</span>.</p>
    <p>В данном примере использован запрос с "<b>условными комметариями</b>". Файл SQL-запроса находится в подкаталоге "sql", относительно каталога, в котором расположен класс <span class="keyword">entity</span>. В качестве краткого примечания отмечу, что строка "##filled{ldelim}$id{rdelim}##" обозначает условие "<b>if</b>" и расшифровывается как "<i>если переданное значение id не пустое - используем кусок SQL-запроса описанный ниже</i>". Cтрока "##--" обозначает завершение "<b>if</b>". Объем данной статьи не позволяет подробно описать синтаксис таких SQL-запросов, но в дополнительных заданиях указаны действия, которые Вы можете выполнить, для общего понимания таких SQL-запросов.</p>

{*==== Test SELECT rowset by Key / Проверка загрузки rowset с помощью ключа ====*}
    <h2>Test SELECT rowset by Key / Проверка загрузки rowset с помощью ключа</h2>
    <dl class="result">
        <dt>Полный массив полученных данных: </dt> <dd><pre>{$rowset_by_key}</pre></dd>
        <dt>Хэш-массив, сформированный из rowset: </dt> <dd><pre>{$hash_by_rowset}</pre></dd>
    </dl>

    <p>В этом примере мы получаем <span class="keyword">rowset</span> с данными сразу из двух связанных таблиц. Для получения этого объекта, как и в предыдущем случае, используем запрос с "<b>условными комметариями</b>". Кроме этого данный пример демонстрирует пример преобразования <span class="keyword">rowset</span> в хэш-массив, с указанием полей, котрые служат для ключа и значения. Также здесь показано как рекомендуется обозначать поля, не относящиеся к таблице с которой работает данный entity.</p>

{*==== Get Top row from linked tables / Получить Top row из связанных таблиц ====*}
    <h2>Get Top row from linked table / Получить Top row из связанной таблицы</h2>
    <dl class="result">
        <dt>Top row: </dt> <dd><pre>{$top_row}</pre></dd>
    </dl>

    <p>В этом примере мы получаем объект <span class="keyword">row</span> с помощью другого объекта <span class="keyword">row</span>. Для выполнения таких действий необходимо, чтобы таблица в БД (исходного row) имела <b>Foreign Key</b> с другой таблицей. При вызове метода указывается название поля связанной таблицы. Далее система сама определяет связь и возвращает объект <span class="keyword">row</span> из связанной таблицы.</p>

{*==== Get Bottom rowset by linked table / Получить Bottom rowset с помощью связанной таблицы ====*}
    <h2>Get Bottom rowset by linked table / Получить Bottom rowset с помощью связанной таблицы</h2>
    <dl class="result">
        <dt>Bottom rowset: </dt> <dd><pre>{$bottom_rowset}</pre></dd>
    </dl>

    <p>Данный пример обратный предыдущему - здесь мы получаем объект <span class="keyword">rowset</span> из таблицы, которая связана с текущей таблицей.</p>

{*==== Table description for "test_subtable" / Описание таблицы "test_subtable" ====*}
    <h2>Table description for "test_subtable" / Описание таблицы "test_subtable"</h2>
    <dl class="result">
        <dt>Table commentary: </dt> <dd><pre>{$comment}</pre></dd>
        <dt>Description of table: </dt> <dd><pre>{$description}</pre></dd>
    </dl>

    <p>Данный пример демонстрирует вспомогательную функцию <span class="keyword">entity</span> - возможность получения описания таблицы БД, с помощью объекта класса <b>\core\service\entity\description</b>. Из примера видно, что данный объект позволяет получить практически полную информацию о таблице, как то: primeryKey; список полей (с детальной информацией о них); список ключей таблицы (с детальной информацией о них); список связей таблицы (с детальной информацией о них); тип таблицы, дату создания таблицы, Collation и комментарий.</p>

{*==== Modify DB-data / Модифицирование DB-данных ====*}
    <h2>Modify DB-data / Модифицирование DB-данных</h2>
    <p>Ближе к концу метода <b>init()</b> файла <b>test_entity.php</b> вы видите четыре примера, демонстрирующих модификацию данных в БД. Все они закомментированы, чтобы не мешать при работе с предыдущими примерами. В рамках самостоятеьной работы Вам необходимо их раскоментировать и проверить их работу. Чтобы было удобнее ставить ибирать комментарий, они написаны таким образом, что вам достаточно просто заменить <b>/*</b> на <b>//*</b>. Т.е добавить или убрать символ "<b>/</b>" в начале каждого комментария.</p>
    <p>Первый пример демонстрирует добавление новой записи в таблицу <b>test_subtable</b>. Результат этого действия Вы можете увидеть в примере "Get Bottom rowset by linked table". Только обратите внимание, что результат этого действия Вы видите только после повторной перезагрузки страницы, поскольку во view передаются данные до модификации. По этой причине, во многих случаях, во view рекомендуется передавать не преобразованный массив, а объекты <span class="keyword">row</span> или <span class="keyword">rowset</span>. Эти объекты хорошо адаптированы для работы с ними в шаблоне и других видах view.</p>
    <p>Второй пример демонстрирует модификацию поля "header", таблицы "test_primary" для строки с id=1. Обратите внимание что объект <span class="keyword">row</span> для данной операции мы могли-бы получить способом, описанным в первом примере, но это было-бы целесообразно, если-бы нам надо было где-то еще использовать значения других полей из этой записи. Если мы хотим выполнить только <b>UPDATE</b> без предварительного <b>SELECT</b>, то целесообразно использовать метод <b>initIdOnly()</b>. Результат этого действия Вы увидите в примере "Get Top row from linked table", но как и предыдущем случае, после повторной перезагрузки страницы.</p>
    <p>Третий пример демонстрирует изменение комментария к таблице "test_subtable". Результат этого действия Вы увидите в примере "Table description for test_subtable", после перезагрузки страницы.</p>
    <p>Четвертый пример демонстрирует возможность обратиться к произвольной таблице в БД, без предварительного создания соответствующего класса для нее. Точнее класс, унаследованный от <b>\core\base\model\entity</b> необходим, но он располагается в произвольном месте, без соблюдения выше описанных правил. Т.о. объект этого класса может работать с любой таблицей в БД. Название таблицы и другие параметры, указываются при получении этого объекта из сервиса "entity". Дальнейшая работа с этим объектом ведется как и с <span class="keyword">entity</span>, полученным стандартным способом. Здесь мы получаем <span class="keyword">row</span> с id=18 и меняем значение его поля "<b>header</b>". Сейчас значение этого поля: <b>{=isset($test_arbitrary) ? $test_arbitrary->header : 'unknown'}</b>. Данный способ получения <span class="keyword">entity</span> может быть использован например, в тех случаях, когда новые таблицы в БД появляются в процессе работы скрипта и зараннее их названия определить невозможно.</p>

{*==== Serialize/unserialize object of row-data / Сериализовать/десериализовать объект строки данных ====*}
    <h2>Serialize/unserialize object of row-data / Сериализовать/десериализовать объект строки данных</h2>
    <dl class="result">
        <dt>Serialized row: </dt> <dd>{$serialize}</dd>
        <dt>Unserialized row object: </dt> <dd><pre>{$test_unserialize}</pre></dd>
    </dl>

    <p>В данном примере мы попытемся сериализовать объект <span class="keyword">row</span>, полученный в первом примере и посмотрим как выглядит этот объект в сериализованном виде. Затем десереиализуем объект и попробуем получить из него данные. Десериализованный объект имеет все те-же функциональные возможности, что и объект созданный обычным способом. Все это означает что мы можем свободно сохранять такие объекты в сессию и потом как угодно ими манипулировать. Это позволяет экономить ресурсы web-сервера, при условии что в сессию сохраняюются те объекты, которые часто используются. Избыток таких объектов в сессии приведет к обратному результату - увеличению нагрузки. Однако, следует учитывать, что если данные в БД изменятся без использования такого объекта, тогда этот объект будет содержать устаревшую информацию.</p>
    <p>Объекты <span class="keyword">rowset</span> можно так-же сериализовать аналогичным образом.</p>


    <div class="add_tasks">
        <h3>Для лучшего овладения материалом:</h3>
        <ul>
            <li>В первом примере попробуйте менять id, указанный как второй аргумент функции gr, чтобы получить разные записи из БД.</li>
            <li>Изучите SQL-запрос во втором примере. Попробуйте изменить условия, заданные в WHERE. Попробуйте менять параметры, передаваемые в метод <b>getRowByKey</b>, в том числе так, чтобы условие в SQL-запросе не выполнилось (т.е. нулевое значение id). Изучите результаты, полученные после каждого изменения.</li>
            <li>Попробуйте различные методы, с разными параметрами в четвертом примере: <b>getArrayAssoc, getColumn, getArrayHash</b>. Проанализируйте полученные результаты.</li>
            <li>В примерах связанных с модифификацией данных раскоментируйте по очереди, описанные куски кода и выполните заданные там действия.</li>
            <li>Попробуйте получить запись из БД способом описанным в первом примере и изменить в ней значения, а затем сохранить в БД.</li>
            <li><b>Усложненное задание</b>: Не меняя порядка тестов в PHP-файле добейтесь чтобы изменения, которые вы вносите во второй части метода сразу же отображались в первой части (без дополнительной перезагрузки страницы). Для этого в шаблон передавайте не массив, а объект <b>row</b>. Преобразование объекта в массив, а затем в строку (с помощью функции <b>print_r</b>) делайте уже в самом шаблоне. Подсказку как это делать найдёте в примере работы с произвольной таблицей БД.</li>
        </ul>
    </div>

    {*==== Show error messages / Отображение сообщений об ошибках ====*}
{else}
    {$check_db}
{/if}
</article>

<div class="back2index">
    <a href="/index.html"><span>Return to list of tests</span><span class="no_unl"> / </span><span>Вернуться к списку тестовых файлов</span></a>
</div>
