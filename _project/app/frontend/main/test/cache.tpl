<article>
    <h1 class="header">PHP-FAN.5: Test of operation with cache<span> / PHP-FAN.5: Проверка работы с кэшем</span></h1>

    {*==== Show result of test / Отображение результатов теста ====*}
    <div class="result">
        <h2>Test file cache</h2>
        <dl>
            <dt>Data: </dt> <dd><pre>{$file_value}</pre></dd>
            <dt>Meta: </dt> <dd><pre>{$file_meta}</pre></dd>
        </dl>

        {if !empty($is_memcache)}
            <h2>Test memory cache</h2>
            <dl>
                <dt>Data: </dt> <dd><pre>{$memory_value}</pre></dd>
                <dt>Meta: </dt> <dd><pre>{$memory_meta}</pre></dd>
            </dl>
        {/if}
    </div>
    {*==== End of Result / Окончание результатов ====*}

    <p>
        Данный файл демонстрирует работу с кэшем. Работа с <span class="keyword">сервисом cache</span> очень похожа на работу с <a href="test_session.php">сервисом session</a>. Здесь точно так-же как и с сессиями, с помощью комманд <b>set()</b> и <b>get()</b> можно сохранять и получать не только скалярные величины, но и массивы или объекты. Главное отличие <span class="keyword">сервиса cache</span> от session в том, что данные сохраненные в сессии будут доступны только текущему пользователю, а все что сохраняется в кэше будет доступно всем клиентам. Это следует учитывать при работе с конфиденциальными данными.
    </p>
    <p>
        <span class="keyword">Сервисом cache</span> использует два ресурса для сохранения данных: файловую систему и php-memcache. Кэш с файловой системой будет работать при любых обстоятельствах (единственное требование - директории для файлов кэша должны быть доступны на запись из php). Для работы с memcache необходимо, чтобы соответствующий <a href="http://www.php.net/manual/en/memcache.setup.php">модуль</a> был установлен в php. В рамках данного теста перед использованием кэша типа memcache проверяется существование класса "\Memcache". Т.о., если соответствующий модуль не установлен, то этот тест выполнятся не будет.</p>
    <p>
        Кэширование на основе memcache в большинстве случаев работает быстрее, чем на основе файловой системы. Но иногда и файловый кэш работает достаточно быстро (за счет аппаратного кэша жесткого диска). Файловый кэш удобен тем, что его емкость ограничена только размером жесткого диска, а это, как правило, превышает потребности проекта в несколько раз. Т.е. емкость файлового кэша можно условно считать неограниченной. Исходя из этого, файловый кэш удобно использовать для тех случаев, когда надо ускорить доступ к данным имеющим достаточно большой объем, а memcache лучше использовать для тех случаев, когда скорость доступа к данным имеет более приоритетное значение.
    </p>
    <p>
        Как и другие сервисы, <span class="keyword">сервис cache</span> требует соответствующей настройки. Давайте рассмотрим параметры задаваемые в config-файле <b>service.ini</b>. Откройте этот файл и найдите секцию "======= Service cache =======". Эта секция разделена на несколько субсекций, по типам данных сохраняемым в кэше. Для каждой субсекции присваивается название и параметры. Для файлового кэша указываются:
    </p>
    <ul class="article_list">
        <li><b>ENGINE</b> - для файлового кэша - всегда "file";</li>
        <li><b>LIFETIME</b> - время "жизни" кэша (параметр можно не указывать если он не отличается от значения по умолчанию "DEFAULT_LIFETIME";</li>
        <li><b>BASE_DIR</b> - директория в которой будут хранится файлы кэша.</li>
    </ul>
    <p>
        Для memcache указываются:
    </p>
    <ul class="article_list">
        <li><b>ENGINE</b> - для memcache - всегда "memcache";</li>
        <li><b>LIFETIME</b> - время "жизни" кэша (параметр можно не указывать если он не отличается от значения по умолчанию "DEFAULT_LIFETIME";</li>
        <li><b>HOST</b> - хост для memcache (по умолчанию "memcache");</li>
        <li><b>PORT</b> - порт для memcache (по умолчанию 11211).</li>
    </ul>
    <p>
        При вызове обекта <span class="keyword">сервиса cache</span> указывается один из типов прописанный в конфиге и, соответственно данные кэша для этого объекта будут сохраняться в выбранное место. Следует учитывать, что кэш также используется системой, поэтому в проекте желательно использовать только те типы кэширования, названия которых начинаются со слова <b>"common_"</b>, либо можно создать свои дополнительные типы.
    </p>
    {assign var='adv' value="service('request')->get('advanced', 'AG', 0)"}
    {if !$adv}
    <p>
        <hr />
        Если Вы хотите больше узнать о кэшировании в PHP-FAN - кликните <a href="cache/advanced-1.html#adv-info">здесь</a>.
    </p>
    {else}
    <a name="adv-info" ></a>
    <h2>Информация для продвинутых разработчиков</h2>
    <p>
        В классической схеме работы фреймворка предусматривается три уровня кэширования:
        <div class="center"><img src="/image/test/ml_cache.png" width="486" height="234" /></div>
    </p>
    <ul class="article_list">
        <li>На <u>нулевом уровне</u> сервис Tab проверяет наличие кэша по указанному запросу (при условии что запрос не POST) и если в кэше данные присутствуют, то формирование блоков не производится - контент отдается непосредственно из кэша. Чтобы использовать этот вид кэширования, в конфигурации сервиса Tab необходимо указать тип используемого кэша и в отдельном конфиге перечислить список URN, для которых разрешено кэширование;</li>
        <li>На <u>первом уровне</u> блоки формируются как обычно, но для тех блоков, для которых сформирован кэш, метод <b>init()</b> не вызывается и на этапе вызова view данные берутся из кэша. Здесь кэш также игнорируется, если запрос передан методом POST. Кроме того, не зависимо от наличия кэша у каждого блока будет вызван метод <b>initRequired()</b> (если такой есть у объекта блока). При отсутствии кэша блока, метод <b>initRequired()</b> вызывается после <b>init()</b>. Чтобы использовать этот вид кэширования, в конфигурации сервиса Tab необходимо указать тип используемого кэша для блоков и в meta-данных указать блоки, для которых разрешено кэширование;</li>
        <li>На <u>втором уровне</u>, внутри блоков данные получаются не из стандартных источников (MySQL, SOAP, REST, и т.д.), а из кэша, который сформирован на основе данных из стандартных источников. Т.о. если источник данных медденный, но данные в нем изменяются редко, а кэширование на уровне таба или блока не возможно, то можно кэшировать сами данные. Фактически, фремворк уже не управляет кэшированием на этом уровне - проверку наличия данных в кэше и сохранение в кэш программист делает самостоятельно. Время хранения данных в кэше должно быть близким к периодичности обновления данных в перво-источнике.</li>
    </ul>
    <p>
        Правильная организация кэширования может во много раз повысить скорость работы проекта и существенно снизить нагрузку на сервер/сервера. Однако следует быть очень осторожным с ограничением "времни жизни" кэша, чтобы пользователи не увидели устаревшую информцию. Наиболее посещаемые страницы можно кэшировать целиком, а динамический контент загружать в них с помощью JavaScript или, на крайний случай, включить кэшироание на уровне блоков. Следует учитывать, что при передаче от клиентов заголовков <b>"HTTP_PRAGMA" = "no-cache"</b> или <b>"HTTP_CACHE_CONTROL" = "no-cache"</b> (нажатие F5 или Ctrl+F5 в браузере), все кэши нулевого и первого уровня, используемые для данного URL - будут сформированы заново. Другими словами, кэш нулевого и первого уровня - будет обновлен при нажатии F5/Ctrl+F5. Кроме того, в "<a href="/__tools/" target="_blank">tools</a>" есть специальная утилита для полной очистки кэша.
    </p>
    {/if}


    <div class="add_tasks">
        <h3>Для лучшего овладения материалом:</h3>
        <ul>
            <li>Попробуйте несколько раз перезагрузить данную страницу и убедитесь, что некоторые данные в результатах теста изменяются. Затем закомментируйте те строки в php-коде, где делается запись в кэш (но не трогайте строки, где данные читаются из кэша) и убедитесь, что у вас отображаются данные из кэша.</li>
            <li>Попробуйте раскоментировать строки где делается удаление из кэша и проверьте удаленные данные.</li>
            {if $adv}
            <li>Попробуйте создать еще один, новый тип кэша и провести с ним запись/чтение/удаление данных.</li>
            <li>Проверьте как работает LIFETIME - уменьшите его значение до минимума. Сохраните данные в кэш и попробуйте их прочитать до и после наступления срока очистки.</li>
            <li>Попробуйте устанавливать кэширование для некоторых тестовых страниц или блоков на этих страницах.</li>
            {/if}
        </ul>
    </div>

</article>

<div class="back2index">
    <a href="/index.html"><span>Return to list of tests</span><span class="no_unl"> / </span><span>Вернуться к списку тестовых файлов</span></a>
</div>
