<article>
    <h1 class="header">PHP-FAN.5: Test of session<span> / PHP-FAN.5: Проверка сессий</span></h1>

    {*==== Show result of test / Отображение результатов теста ====*}
    <dl class="result">
        <dt>Data application session:<br />Данные сессии application:</dt> <dd><pre>{$test1}</pre></dd>
        <dt>Data block session:      <br />Данные сессии блока:</dt>       <dd><pre>{$test2}</pre></dd>
        <dt>Data custom session:     <br />Данные специальной сессии:</dt> <dd><pre>{$test3}</pre></dd>
    </dl>
    {*==== End of Result / Окончание результатов ====*}

    <p>
        Данный файл демонстрирует работу с сессиями. В системе предусмотрено много уровней изоляции данных сохраняемых в сессии. Здесь мы рассмотрим основные.
    </p>
    <h2>Изоляция на уровне текущего application</h2>
    <p>
        Этот тип изоляции используется по умолчанию, т.е. <span class="keyword">сервис session</span> вызывается без каких-либо параметров. При этом данные, сохраняемые в сессию, будут доступны только в пределах данного application. Другими словами, если например в application "frontend" сохранить в сессию элемент с ключом "x1", то в другом application этот элемент не будет доступен. Более того, в другом application можно сохранить другой элемент с ключом "x1" и они не пересекутся. При этом, на уровне php сохранение сессии выполняется как обычно, в массив $_SESSION, но обращаться к этому массиву напрямую категорически не рекомендуется.
    </p>
    <h2>Изоляция на уровне блока</h2>
    <p>
        Данные, которые сохраняются в сессию таким способом, будут доступны только объектам (блокам) текущего класса. Другими словами, если Вы сохраняете какое-либо значение таким способом, то из блоков созданных на основе других классов эти данные не будут доступны. Для удобства сохранения/получения данных использутся методы: <span class="keyword">$this->setSessionData($sKey, $mValue);</span> / <span class="keyword">$this->getSessionData($sKey);</span>. Очень часто сессия используется для однократной передачи данных между друмя сеансами. Т.е. при одном обращении даные сохраняются в сессию, а при последующем обращении должны быть прочитаны и удалены из сессии. Для упрощения этого процесса и предназначен третий параметр метода <b>getSessionData</b>.
    </p>
    <h2>Custom-данные</h2>
    <p>
        Существуют отдельные массивы данных типа "custom". Для таких данных указывается "<b>namespace</b>" в виде любой текстовой строки (не путать с namespace класса), при вызове объекта <span class="keyword">сервиса session</span>. Указывается "<b>namespace</b>" как второй аргумент функции service, например: <b>service('session', 'ns1')</b>. Область видимости таких данных ограничена только указанным "<b>namespace</b>" и при правильном его указании, эти данные будут доступны из любой точки проекта, не зависимо от application и других условий.
    </p>
    <h2>Общая информация</h2>
    <p>
        В сессии можно сохранять не только скалярные величины но и массивы или объекты. Если все свойства сохраняемого в сессии объекта, являются скалярными величинами, то обычно такие объекты сохраняются без каких-либо дополнительных методов. Для сложных классов лучше использовать "implements Serializable". Если есть возможность восстановить какие-то свойства объекта после чтения его из сессии, то во многих случаях нецелесообразно сохранять эти свойства в сессии. Характерным примером являются объекты класса <b>\core\base\model\row</b>, специально адаптированные для сохранения в сессии или <a href="test_cache.php">кэше</a>. Такой объект (запись из БД), содержит ссылку на объект entity, с помощью которого он был получен. При этом ссылка на объект entity в сессию не сохраняюется, но сохраняются параметры, с помощью которых этот объект может быть восстановлен.
    </p>
    <p>
        В сессии сохраняются еще множество служебных данных, например: данные авторизованного пользователя и его роли, некоторые сервисы хранят свою информацию в сессии, и т.д. Для таких данные создаются отдельные группы namespace и, при использовании вышеописанных методов работы, эти данные никогда не "пересекутся". Прямое обращение к служебным данным (даже через <span class="keyword">сервис session</span>) категорически не рекомендуется. Для работы с такими данными используйте те сервисы, для которых они предназначены.
    </p>


    <div class="add_tasks">
        <h3>Для лучшего овладения материалом:</h3>
        <ul>
            <li>Попробуйте несколько раз перезагрузить данную страницу и убедитесь, что данные в результатах теста изменяются. Затем закомментируйте те строки в php-коде, где делается запись в сессию (но не трогайте строки, где данные читаются из сессии) и убедитесь, что у вас отображаются данные из предыдущего сеанса.</li>
            <li>Попробуйте изменять namespace для custom-сессии и сохранять/получать данные из разных namespace.</li>
            <li>Попробуйте использовать автоочистку сессии, опичанные в подразделе "<b>Изоляция на уровне блока</b>".</li>
        </ul>
    </div>
</article>

<div class="back2index">
    <a href="/index.html"><span>Return to list of tests</span><span class="no_unl"> / </span><span>Вернуться к списку тестовых файлов</span></a>
</div>
