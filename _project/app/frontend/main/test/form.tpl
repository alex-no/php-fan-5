<article>
    <h1 class="header">PHP-FAN.5: Test HTML-form <span>/ PHP-FAN.5: Тестирование HTML-форм</span></h1>

    <h2>Построение HTML-форм в PHP-FAN</h2>

    <p>Проектирование любой формы основано на следующих составляющих:</p>
    <div id="form_struct">
        <div id="form_img">
            <img src="/image/test/form_struct.png" width="314" height="192" alt='Structure of form' />
        </div>
        <div id="form_descr">
            <dl class="art_def">
                <dt>Структура формы</dt>
                <dd>- одна из основных составляющих формы. Описание струкруры формы делается в мета-файле блока, содержащего форму. В мета-файле указываются общие параметры формы, параметры каждого поля (имя поля, тип, правила валидации и т.п.) и патерны HTML-элементов, для формирвания HTML-кода формы. Рамки данного теста не позволяют подробно описать все параметры мета-файла (подробное описание будет в документации к PHP-FAN). Пример всех параметров, которые можно указывать в метафайле можно посмотреть в <b>{$meta_example}</b> и назначение большинства параметров понятно из их названий или комментариев, в данном примере.</dd>
                <dt>Контроллер формы</dt>
                <dd>- класс блока формы. Как будет видно из примера - класс чаще всего, содержит сравнительно простой и короткий PHP-код. Класс блока должен быть унаследован от \core\block\form\usual или от другого класса, являющегося наследником \core\block\form\usual. В методе init() блока, могут задаваться дополнительные параметры визуализации формы и выполняться другие не стандартные операции. Но обязальным действием, которое необходимо выполнить в методе init() - является вызов парсинга формы: <b>$this->_parseForm();</b> (см. следующий пункт). Так-же в этом классе создаются методы <b>onSubmit()</b> и <b>onError()</b>, в которых указываются действия, которые необходимо выполнить при успешной валидации формы или при ошибке. Если никаких действий выполнять не нужно - эти методы создавать не обязательно.</dd>
                <dt>Парсер формы</dt>
                <dd>- объект класса <b>\core\service\form</b>. Процесс парсинга начинается с анализа данных, которые пришли в текущем запросе к серверу. Если парсер определяет, что данные, которые пришли в запросе, относятся к текущей форме - начинается процесс их обработки. Сначала полученные данные валидируются в соответствии с заданной структурой и в зависимости от результатов парсинга вызываются методы <b>onSubmit()</b> или <b>onError()</b>.</dd>
                <dt>Шаблон формы</dt>
                <dd>- шаблон блока формы. Шаблоном формы является шаблон блока. Специфической особенностью этого шаблона является то что в нем есть специальные шаблонные теги, из которых формируются элементы формы. Формирование элементов формы осуществляется на основе паттернов, заданных в мета-файле родительского блока. Обычно существующих паттернов достаточно для большинства форм, но при необходимости можно добавлять свои паттерны в мета-файл текущего блока.</dd>
            </dl>
        </div>
    </div>

    {*==== Show result of test / Отображение результатов теста ====*}
    <div class="result">
        {$test_form}
    </div>
    {*==== End of Result / Окончание результатов ====*}

    <p>Допускается основной блок страницы использовать как составляющие элементы формы. Но более правильным решением будет выделение каждой формы в отдельный блок и размеещение этих блоков в отдельной директории. Именно так и сделано в данном тесте - элементы данной фoрмы расположены в каталоге <b>{$form_block['dirname']}</b>:</p>
    <dl class="form_elements">
        <dt>{$form_block['filename']}.meta.php</dt><dd>- meta-файл со структурой формы.</dd>
        <dt>{$form_block['basename']}</dt><dd>- основной контроллер формы.</dd>
        <dt>{$form_block['filename']}.tpl</dt><dd>- шаблон формы.</dd>
    </dl>
        <p>Данная форма сравнительно простая - всего три поля (изучите meta-файл этого блока). Все три поля предсавлены как типовые (наиболее распространенный способ представления: лейбл, поле для ввода/выбора информации, примечание, сообщение об ошибке). Рассмотрите внимательно шаблон формы - здесь два поля "text1" и "variant" представлены в сокращенном виде: <b>{ldelim}form_row name='text1'{rdelim}</b> и <b>{ldelim}form_row name='variant'{rdelim}</b>. А для поля "date" составляющие элементы этого поля разделены: <b>&lt;div class="formRow"&gt;{ldelim}form_label name='date'{rdelim}{ldelim}form_field name='date'{rdelim}{ldelim}form_error name='date'{rdelim}{ldelim}form_note name='date'{rdelim}&lt;/div&gt;</b>. Такое разделение дает верстальщику определенную свободу в манипуляции элементами не стандартной формы, но усложняет читабельность шаблона. Во многих случаях, для решения такой задачи, гораздо целесообразнее изменить или добавить "паттерн шаблона" в мета-данные блока. Что такое "паттерн шаблона" вы можете понять, заглянув в метафайл, расположенный рядом с классом: \core\block\form\usual, от которого наследуются все блоки форм.</p>
        <p>Теперь рассмотрим php-файл формы. Он достаточно простой (4 метода по 1-2 процедуры в каждом). Большинство классов форм в PHP-FAN достаточно простые за счет того, вся структура формы задана в мета-данных, а обработка формы, согласно структуре происходит в родительских классах и в сервисе <span class="keyword">form</span>. В методе init() следует обратить внимание вызов метода <b>$this-&gt;_parseForm();</b> - именно в этот момент происходит вызов сервиса <span class="keyword">form</span> и обработка данных, переданных с помощью формы. Порядок обработки описан ниже. Успешно обработанные данные сохранются в сессии (см. метод onsubmit()), а после перезагрузки страницы извлекаются (см. метод init()) и передаются во view для отображения. Метод <b>checkDate</b> демонстрирует как для форм можно создавать свои, не стандартные, правила валидации (обратите внимание на то, как этот метод обозначен в meta-файле). Метод <b>getVariants</b> демонстрирует как таких элементов как select, radio, и.т.д. можно динамически генерировать список данных. Сейчас этот метод возвращает обычный статичный массив, но на практике такие данные формируются динамически из БД или других источников.</p>
        <p>Рамки данного теста не позволяют раскрыть всех возможностей, которые есть в PHP-FAN для работы с формами. Тем не менее раскрытых здесь возможностей хватает для построения большинства форм. Для решения более сложных вариантов следует обратиться к документаии.</p>



    <h2>Принципы работы с HTML-формами в PHP-FAN</h2>

    <p>Каждая форма в PHP-FAN выполняется в виде блока или блоков. Т.е. одна форма может состоять из нескольких блоков, но никогда один блок не должен включать в себя несколько форм. Другими словами, формы в PHP-FAN можно разделить на два вида:</p>
    <dl class="art_def2">
        <dt>Одно-блочные</dt>
        <dd>- весь функционал формы выполняется в виде одного блока, который выполняет все действия от прорисовки HTML-кода формы, до обработки результатов.</dd>
        <dt>Много-блочные</dt>
        <dd>- вся форма разбивается на несколько частей (блоков). Каждая часть может включать в себя один или несколько элементов (тегов) формы. Один из блоков, составляющих форму, обозначается как <b>основной</b>. Чаще всего это блок включающий в себя остальные блоки, но не обязательно - как основной может быть отмечен и вложенный блок (как удобно из логики обработки данных). Все остальные блоки называются "<b>суб-формами</b>" или <b>sub_form</b>. При этом <u>каждый блок контролирует свою часть формы</u> (формирует HTML-код, валидирует и обрабатывает полученные данные). При обработке данных, сначала валидируются и обрабатываются данные субформ (порядок обработки субформ задается основным блоком). Затем обработанные данные и информация об ошибках передается в основной блок. После этого выполняется обработка всех данных (полученные от субформ и от собственных элементов основной формы).</dd>
    </dl>

    <p>Работу с любой формой можно разделить на несколько шагов:</p>
    <ol class="article_list">
        <li><b>Получение структуры формы</b> - источником данных здесь служит мета-файл файл блока с формой или субформой.{* В мультиформах - основной блок собирает данные от субформ и формирует общую структуру.*}</li>
        <li><b>Передача данных для валидации в JavaScript</b> - выполняет блок формы (в мультиформах - основной блок).</li>
        <li><b>Подготовка данных для элементов</b> - некоторые элементы (select, radio, checkbox и т.п.) требуют дополнительные данные для отображения. Способ получения таких данных определяется в мета-файле. Данные берутся либо из самого мета-файла, либо их возвращает метод текущего блока, либо статический метод произвольного класса (обычно это класс entity).</li>
        <li><b>Подготовка исходных значений элементов</b> - в некоторых случаях требуется сделать предзаполнение элементов формы (например, вписать определенный текст в input-text, выбрать определенную опцию у select и т.п.). Эта информация либо также указывается в meta-файле, либо задается вызовом специального метода.</li>
        <li><b>Формирование HTML-кода</b> - каждый блок формирует свою часть формы. Элементы формы формируются с помощью паттернов, которые описаны ниже. Полный HTML-код многоблочной формы формирует блок, в который включены остальные блоки (шаблон этого блока должен содержать теги &lt;form&gt; и &lt;/form&gt;). Сформированный код передается или в общий HTML-шаблон или отдается в JavaScript для динамического отображения.</li>
        <li><b>Предварительная валидация в JavaScript</b> - выполняется в браузере клиента, в процессе заполнения формы клиентом или непосредственно перед отправкой на сервер. Такая валидация не позволяет пользователю отправлять не валидные данные на сервер, чем ускоряется работа пользователя с формой и снижается нагрузка на сервер.</li>
        <li><b>Отправка данных на сервер</b> - выполняется либо стандартным способом, либо с помощью JavaScript. В зависимости способа отправки, обработка формы выполняется по разному.</li>
        <li><b>Валидация и подготовка данных</b> - выполняется с помощью класса <b>\core\service\form</b>. Объекты этого класса создаются отдельно для каждого блока субформы и, соответственно обрабатывает свою часть данных. Стоит отметить, что валидация, описанная в 6-м шаге может легко обходиться хакерами и поэтому все данные формы, не зависимо от валидации в JavaScript, должны повторно валидироваться на сервере.</li>
        <li><b>Обработка данных</b> - если валидация данных прошла успешно то вызывается метод <b>onSubmit</b> основного блока и в него передаются подготовленные данные.</li>
        <li><b>Перезагрузка</b> - если данные формы были переданы методом POST и обрабтка данных прошла успешно, то обычно после этого происходит перезагрузка страницы. Такая перезегруза защищает пользователя от случайной повторной отправки данных на сервер. Обычно перезагрузка происходит по текущему URL и после перезагрузки пользователю в корневом блоке отображается не форма, а информация об успешной обработке переданных данных.</li>
        <li><b>Информация об ошибках</b> - к этому шагу переходим если на 8-м шаге при валидации были обнаружены ошибки. После этого возвращаемся ко 2-му шагу, но с небольшой оговоркой - на 4-м шаге, в качестве исходных значений используем данные введенные пользователем, а на 5-м шаге вместе с элементами формы выводятся сообщения об ошибках.</li>
    </ol>
    <p>Отдельно необходимо рассмотреть шаг 6 "Предварительная валидация в JavaScript". Часть данных для валидации формы передается в JavaScript вместе со сформированным HTML-кодом формы. Сюда относятся правила валидации на основе статичных данных: обязательность заполнения, соответствие регулярному выражению, число в заданном диапазоне и т.п. Но некоторые способы валидации (например, проверка уникальности введенного логина или email) требуется дополнительный запрос к серверу. При этом URL для такого запроса должен быть составлен таким образом, чтобы выполнялась только валидация указанного поля/полей с помощью сервиса <b>\core\service\form</b>, но по правилам, описанным в блоке с формой. Другими словами, не должно быть дублирующего описания правил валидации в разных блоках.</p>

    <p>С точки зрения практического использования формы можно разделить на две группы:</p>
    <dl class="art_def2">
        <dt>Формы-фильтры</dt>
        <dd>- эти формы используются для ограничения списка выводимых данных (данные выводятся в другом блоке). Такие формы не имеют метода <b>onSubmit</b> (см. 9-й шаг), точнее этот метод пустой, т.к. данные передаваемые на сервер никак не обрабатываются формой (точнее никуда не заносятся, кроме, может быть статистики, но это отдельный процесс). К формам такого типа относятся и поисковые формы. Формы такого типа обычно передают свои данные методом GET (чтобы полученную ссылку можно было внести в закладки, переслать другим пользователям и т.д)</dd>
        <dt>Формы-данные</dt>
        <dd>- эти формы используются для ограничения для передачи каких либо данных на сервер. Это могут как формы, данные которых сохраняются на сервере (например, регистрация новых пользователей) или просто проверяются (проверка логина/пароля). В любом случае данные такой формы после валидации требуют дополнительной обработки в методе <b>onSubmit</b>.</dd>
    </dl>
    <p>В некоторых случаях имеет смысл на уровне проекта содать два промежуточных класса для этих двух групп, прописать в них основные значения, по умолчанию, и все типовые формы в проекте наследовать от этих классов.</p>

    <p>С точки зрения дизайна формы можно разделить тоже на две группы:</p>
    <ul class="article_list">
        <li><b>Типовые формы</b> - каждый элемент формы представлен в виде нескольких стандартных элементов: лейбл -&gt; тег элемента формы -&gt; примечание к элементу -&gt; сообщение об ошибке.</li>
        <li><b>Не стандартные</b> - каждый элемент формы выводится в произвольном виде.</li>
    </ul>

    <div class="add_tasks">
        <h3>Для лучшего овладения материалом:</h3>
        <ul>
            <li>Попробуйте в мета-данных изменить 'input_type' для поля 'variant' с 'select' на 'radio_group'. В качестве примера соответствующая строка в meta-файле закоментирована.</li>
            <li>Данные для поля 'variant' сейчас берутся непосредственно из meta-файла. Попробуйте получить их с помощью метода getVariants, описанного высше.</li>
            <li>Попробуйте изменить граничные значения для валидации поля date, а затем введите запредельное значение и посмотрите на результат.</li>
            <li>Попробуйте изменить в шаблоне порядок элементов для поля date.</li>
            <li>Добавьте в форму одно или несколько своих полей - их надо прописать meta-файле и в шаблоне.</li>
        </ul>
    </div>
</article>

<div class="back2index">
    <a href="/index.html"><span>Return to list of tests</span><span class="no_unl"> / </span><span>Вернуться к списку тестовых файлов</span></a>
</div>
